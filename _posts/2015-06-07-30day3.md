---
layout: post
title: 自制操作系统(3)—进入32位模式并导入C语言
category: 技术
tags: 操作系统 
description: 30天自制操作系统第三天
---

目前为止，我们只完成了一个显示hello world的引导程序，甚至都不算引导程序，因为它根本啥都没引导。接下来的任务就是让它引导一个真正的程序，然后我们还要用加入C语言来实现它。

## 真正的引导

### 装载磁盘内容到内存

首先需要做的就是将磁盘中的内容读入到内存中。
为了读取主引导扇区后面一个扇区的内容，需要添加如下代码：

    MOV		AX,0x0820
	MOV		ES,AX
	MOV		CH,0			; 柱面0
	MOV		DH,0			; 磁头0
	MOV		CL,2			; 扇区2

	MOV		AH,0x02			; AH=0x02 : 读盘
	MOV		AL,1			; 1个扇区
	MOV		BX,0
	MOV		DL,0x00			; A驱动器
	INT		0x13			; 调用磁盘BIOS
	JC		error

这里调用了19号BIOS中断，19号BIOS中断是用与磁盘IO的，用法如下：

- AH=0x02（读盘）
- AH=0x03（写盘）
- AH=0x04（校验）
- AH=0x0c（寻道）
- AL=处理对象的扇区数（只能同时处理连续的扇区）
- CH=柱面号&0xff
- CL=扇区号(0-5)\|(柱面号&0x300)>>2
- DH=磁头号
- DL=驱动器号
- ES:BX=缓冲地址
- 返回值：
	- FLACS.CF==0：没错误，AH==0
	- FLACS.CF==1：有错误 ，错误号存入AH内

这里使用了AH=0x02，也就是读盘功能，将磁盘中0柱面，0磁头，2扇区的内容读入地址0x0820:0000处。最后的`error`指向之前打印hello world的那段程序，只不过“hello world”已经变成了“load error”。

借助于BIOS调用，我们就可以将磁盘中指定的内容读入内存中。

将磁盘中连续10个柱面的内容装载到内存中的代码如下：
    
		MOV		AX,0x0820
		MOV		ES,AX
		MOV		CH,0			; 柱面0
		MOV		DH,0			; 磁头0
		MOV		CL,2			; 扇区2
	readloop:
		MOV		SI,0			; 记录失败次数的寄存器
	retry:
		MOV		AH,0x02			; AH=0x02 : 读入磁盘
		MOV		AL,1			; 1个扇区
		MOV		BX,0
		MOV		DL,0x00			; A驱动器
		INT		0x13			; 调用磁盘BIOS
		JNC		next			; 没出错时跳转到next
		ADD		SI,1			; SI加1
		CMP		SI,5			; 比较SI与5
		JAE		error			; SI >= 5 时，跳转到error
		MOV		AH,0x00
		MOV		DL,0x00			; A驱动器
		INT		0x13			; 重置驱动器
		JMP		retry
	next:
		MOV		AX,ES			; 把内存地址后移0x200
		ADD		AX,0x0020
		MOV		ES,AX
		ADD		CL,1			; CL加1
		CMP		CL,18			; CL与18比较
		JBE		readloop		; 如果CL<=18，跳转至readloop
		MOV		CL,1
		ADD		DH,1
		CMP		DH,2
		JB		readloop		; 如果DH<2，跳转到readloop
		MOV		DH,0
		ADD		CH,1
		CMP		CH,CYLS
		JB		readloop		; 如果CH<CYLS，跳转到readloop

将这段代码保存为ipl.nas（.nas是作者采用的汇编文件后缀，与编译器nask.exe配合使用）再用nask将ipl.nas编译成二进制文件ipl.bin，准备好后我们便开始准备被引导的程序了。

### 从启动区执行操作系统

首先新建文件haribote.nas：

    fin：
	    HLT
	    JMP fin

用nask编译，输出成haribote.sys，然后结合ipl.bin把这个文件保存到磁盘映像haribote.img里。整个过程借助Makefile自动实现，为了说明依赖关系，节选出Makefile中相关部分：

    ipl10.bin : ipl10.nas Makefile
	$(NASK) ipl10.nas ipl10.bin ipl10.lst

	haribote.sys : haribote.nas Makefile
		$(NASK) haribote.nas haribote.sys haribote.lst
	
	haribote.img : ipl10.bin haribote.sys Makefile
		$(EDIMG)   imgin:../z_tools/fdimg0at.tek \
			wbinimg src:ipl10.bin len:512 from:0 to:0 \
			copy from:haribote.sys to:@: \
			imgout:haribote.img

我们这么做的目的就是要看一看haribote.sys在磁盘映像内部是如何保存的，因为我们已经知道如何将磁盘上的内容装载到内存中，只要再知道haribote.sys在磁盘中是如何保存的，就可以知道haribote.sys在内存中的位置，也就可以执行那段代码了。

用二进制编辑器（我用的Visual  Studio）查看haribote.img可以发现，文件名写在0x002600处：

![](http://7xikhf.com1.z0.glb.clouddn.com/2600.png)

文件内容写在0x004200处：

![](http://7xikhf.com1.z0.glb.clouddn.com/4200.png)

因为磁盘是从第2个扇区开始，装载到0x008200处的，8200H-512=8000H，所以文件内容在内存中的位置是0x008000+0x004200=0x00c200。

为了验证这一想法，改写haribote.nas如下：

    ; haribote-os
	; TAB=4

		ORG		0xc200

		MOV		AL,0x13		; VGA显卡，320*200*8位彩色
		MOV		AH,0x00
		INT		0x10
	fin:
		HLT
		JMP		fin

设定AH=0x00后，16号BIOS中断就是显卡调用，这样就可以切换显示模式了：

- AH=0x00
- AL=模式：
	- 0x03：16色字符模式，80*25
	- 0x12：VGA图形模式，640*480*4位彩色
	- 0x13：VGA图形模式，320*200*8位彩色
	- 0x6a：扩展VGA模式，800*600*4位彩色
- 返回值：无

另外，我们需要在ipl.nas处理的最后加上`JMP 0xc200`，如果一切正常，窗口应该是一片漆黑的，make，执行，一片漆黑：

![](http://7xikhf.com1.z0.glb.clouddn.com/vga_bladk.png)

## 向C语言进发

### 准备工作

首先需要进入32位模式，所谓的32位模式，指的是CPU的模式。不同的模式下使用的寄存器是有区别的，机器语言的解释方法也不一样。32位的好处就是使用的内存容量将远远大于16位下的1M，CPU也可以识别出可疑的机器语言，实现自我保护。

要想在32位模式下使用C语言编写的程序，haribote.sys要有所变化。haribote.sys将不单单由haribote.nas生成，它会由两部分构成（并不是简单组合在一起，稍后细说），前面是用汇编语言编写的asmhead.nas，后面则是用C语言编写的bootpack.c。在这里，由C源文件到机器语言是一个
复杂的转换过程，Makefile中有关生成规则的部分是这样的：

    default :
	$(MAKE) img
	
	# 生成规则
	
	ipl10.bin : ipl10.nas Makefile
		$(NASK) ipl10.nas ipl10.bin ipl10.lst
	
	asmhead.bin : asmhead.nas Makefile
		$(NASK) asmhead.nas asmhead.bin asmhead.lst
	
	bootpack.gas : bootpack.c Makefile
		$(CC1) -o bootpack.gas bootpack.c
	
	bootpack.nas : bootpack.gas Makefile
		$(GAS2NASK) bootpack.gas bootpack.nas
	
	bootpack.obj : bootpack.nas Makefile
		$(NASK) bootpack.nas bootpack.obj bootpack.lst
	
	naskfunc.obj : naskfunc.nas Makefile
		$(NASK) naskfunc.nas naskfunc.obj naskfunc.lst
	
	bootpack.bim : bootpack.obj naskfunc.obj Makefile
		$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \
			bootpack.obj naskfunc.obj
	# 3MB+64KB=3136KB
	
	bootpack.hrb : bootpack.bim Makefile
		$(BIM2HRB) bootpack.bim bootpack.hrb 0
	
	haribote.sys : asmhead.bin bootpack.hrb Makefile
		copy /B asmhead.bin+bootpack.hrb haribote.sys
	
	haribote.img : ipl10.bin haribote.sys Makefile
		$(EDIMG)   imgin:../z_tools/fdimg0at.tek \
			wbinimg src:ipl10.bin len:512 from:0 to:0 \
			copy from:haribote.sys to:@: \
			imgout:haribote.img

从中我们可以看出主要有以下几步：

- 首先，使用ccl.exe从bootpack.c生成bootpack.gas。
- 第二步，使用gas2nask.exe从bootpack.gas生成bootpack.nas。
- 第三步，使用nask.exe从bootpack.nas生成bootpack.obj。
- 第四步，使用obi2bim.exe从bootpack.obj生成bootpack.bim。
- 最后，使用bim2hrb.exe从bootpack.bim生成bootpack.hrb。
- 这样就做成了机器语言，再使用copy指令将asmhead.bin与bootpack.hrb单纯结合起来，就成了haribote.sys。

巨复杂吧，其中使用的好多工具都是作者写的，我们只要大概知道这一流程，然后使用合适的工具去完成就好，不必深究。但需要明确的是其中的链接器obj2bim，它是用来将可重定位的目标文件（Win上是.obj，Linux上是.o）链接起来的，而可重定位的目标文件来源于不同的源文件，稍后我们就会用它将两个目标文件连接成bootpack.bim。

asmhead.nas是用来做一些初始工作的，它里面的内容有些复杂（还是日文注释），需要学习后面的知识才能理解，其中关于显卡和键盘状态的内容如下：

    CYLS	EQU		0x0ff0			; 设定启动区
	LEDS	EQU		0x0ff1
	VMODE	EQU		0x0ff2			; 关于颜色数目的信息
	SCRNX	EQU		0x0ff4			; 分辨率的X
	SCRNY	EQU		0x0ff6			; 分辨率的Y
	VRAM	EQU		0x0ff8			; 图像缓冲区的开始地址
	
			ORG		0xc200			; 程序在内存中的装载位置
	
			MOV		AL,0x13			; VGA显卡320x200x8位彩色
			MOV		AH,0x00
			INT		0x10
			MOV		BYTE [VMODE],8	; 记录画面模式
			MOV		WORD [SCRNX],320
			MOV		WORD [SCRNY],200
			MOV		DWORD [VRAM],0x000a0000
	
	; 用BIOS取得键盘上各种LED指示灯的状态
	
			MOV		AH,0x02
			INT		0x16 			; keyboard BIOS
			MOV		[LEDS],AL

从程序中我们发现，将0xa0000（取决于图像模式）作为了图像缓冲区的开始地址[VRAM]，VRAM指的是用来显示画面的内存，将不同的内容读入到这一地址，就可以在屏幕上显示不同的画面了。

bootpack.c的内容就简单了，就是一个死循环：

    void HariMain(void)
    {
	    fin:
		    goto fin;
	}

### 实现HLT

在C语言中要实现HLT必须要借助汇编，提供这一接口的是naskfunc.nas：

    ; naskfunc
	; TAB=4
	
	[FORMAT "WCOFF"]				; 制作目标文件的模式
	[BITS 32]						; 制作32位模式用的机械语言
	
	; 制作目标文件的信息
	
	[FILE "naskfunc.nas"]			; 源文件名
	
			GLOBAL	_io_hlt			; 程序中包含的函数名
	
	; 以下是实际的函数
	
	[SECTION .text]		; 目标文件中写了这些以后再写程序
	
	_io_hlt:	; void io_hlt(void);
			HLT
			RET

在naskfunc.c中，除了一些必要的声明外，用汇编实现了一个函数，这个函数就是提供给C源文件的，它在bootpack.c中的使用情况如下：

    void io_hlt(void);

	void HariMain(void)
	{
		fin:
			io_hlt();
			goto fin;
	}

就跟普通的C函数一样。

将由这两个文件生成的目标文件链接在一起就可以生成bootpack.bim，从而进一步生成haribote.sys。

忙活了这么半天，还是一片漆黑。。。可怜了一双好色的眼啊！